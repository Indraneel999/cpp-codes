*********ARRAYS*************

----------------------------------------------------------------------
        KADANEâ€™S ALGORITHM

    int ans = INT_MIN;
    int sum = 0;
    for(i = 0 to n) {
        sum += a[i];
        if(ans < sum)
        ans = sum;
        if(sum < 0)
            sum = 0;
    }

    Maximum Product Subarray

    int maxProduct(vector<int>& nums) {
        int maxproduct = nums[0];
        int minproduct = nums[0];
        int maxres = nums[0];
        for(int i = 1; i < nums.size(); i++) {
            if(nums[i] >= 0) {
                maxproduct = max(nums[i], maxproduct*nums[i]);
                minproduct = min(nums[i], minproduct*nums[i]);
            }
            else {
                int temp = maxproduct;
                maxproduct = max(nums[i], minproduct*nums[i]);
                minproduct = min(nums[i], temp*nums[i]);
            }
            maxres = max(maxres, maxproduct);
  }
        
        return maxres;
    }
---------------------------------------------------------------------------------------
    SUB-ARRAY WITH GIVEN SUM


    j=0;
    //s contains the desired sum
    while(t--)
    {
        result = 0;
        cin>>n>>s;
        arr.resize(n);
        for(i=0;i<n;i++)
        {
            cin>>arr[i];   
            result+=arr[i];  //checking while inserting
            while(result > s && j<=i)//keep removing element until result greater than sum
            {
                result-=arr[j];
                j++;
            }
            if(result == s)
            {
                cout<<j+1<<" "<<i+1<<"\n";
                break;  //stops taking input once the sum is matched
            }
        }
        if(i==n)
            cout<<"-1\n";
    }

  ---------------------------------------------------------------------------
   SORT ARRAY CONTAINING 0 1 AND 2

 APPROACH 1
  using three way partitioning

  void sort_array(vector<long long> &a)
{
    //i is used to traverse the array 
    //low stores the starting location where next 0 is to be put
    //high stores the location where next 2 is to be placed
    long low=0,i=0,high = a.size()-1;
    while(i <= high)
    {
        if(a[i] == 0)
            swap(&a[i++],&a[low++]); //reference also works in vectors
        else
            if(a[i]==1)
                i++; // low and i will be different when we get first 1
        else
            if(a[i]==2)
                swap(&a[i],&a[high--]);
    } 
}

  APPROACH 2
   counting occurrences of 0 1 and 2


   void sort_array(vector<long long>& arr)
  {
    vector<long long> count(3,0);
    for(long long i=0;i<arr.size()-1;i++)
        count[arr[i]]++;
    for(long long i=0;i<count[0];i++)
        arr[i]=0;
    for(long long i=count[0];i<(count[1]+count[0]);i++)
        arr[i]=1;
    for(long long i=(count[1]+count[0]);i<arr.size();i++)
        arr[i]=2;
}

-------------------------------------------------------------------------

 REVERSE ARRAY IN GROUPS

        for(i=0;i<n;i+=k)
       {
           j=i;
           a=1;
           if((i+k)>n) //if it exceeds array size
                k = n-i;
             while(j<(i+k-a)) //swap with the corresponding element
            {
                temp = arr[j]; 
                arr[j] = arr[i+k-a]; // a is used to decrement end position each time
                arr[i+k-a] = temp;   
                j++;
                a++;
            }
         } 

 -----------------------------------------------------------------------------------

 TRAPPING RAIN WATER

 ll trapping_water(vector<ll> &arr)
{
    ll left=0,right=arr.size()-1; //to store the indices
    ll max_left=0,max_right=0; //to store the maximum height bar from left and right
    ll res=0;
    while(left<=right)
    {
        if(arr[left] < arr[right]) // need to check this else suppose decreasing order height
        {
            if(arr[left]>max_left)
                max_left = arr[left];
            else
                res+=max_left-arr[left];
            left++;
        }

        else
        {
            if(arr[right]>max_right)
                max_right = arr[right];
            else
                res+=max_right-arr[right];
            right--;
        }

    }
    return res;
}
-----------------------------------------------------------------------------------------
PYTHOGOREAN TRIPLET- a2 + b2 = c2

bool find_triplet(vector<int> &arr)
{
    //recieved an array after squaring all of it's elements

    sort(arr.begin(),arr.end()); //sort
    ll left,right;
    for(ll i=arr.size()-1;i>1;i--)  
    { 
        left = 0;
        right = i-1;
        while(left < right) //apply meet in middle algorithm
        {
            if(arr[left]+arr[right]<arr[i])
                left++;
            else if(arr[left]+arr[right]>arr[i])
                right--;
            else 
                return 1;
        }
    }
    
    return 0;
}
-------------------------------------------------------------------------------

BUY SELL

/*
The cost of stock on each day is given in an array A. 
Find all the days on which you buy and sell the stock 
so that in between those days you shouldn't have any loss
i/p-100 180 260 310 40 535 695
o/p- (0 3) (4 6)
*/

void buy_sell(vector<int> &arr)
{
    int max;
    int i=arr.size()-1;
    vector< pair<int,int> > result;
    while(i>0 && arr[i-1]>arr[i])
        i--;
    max = i;
    i--;
    while(i>=0)
    {
        if(arr[i]>arr[max])
        {
            pair<int,int> foo = make_pair(i+1,max);
            result.push_back(foo);
            max = i;
        }
        i--;
    }
    pair<int,int> foo = make_pair(i+1,max);
    result.push_back(foo);
    
    for(i=result.size()-1;i>=0;i--)
    {
        cout<<"("<<result[i].first<<","<<result[i].second<<") ";
    }
    cout<<"\n";
}
---------------------------------------------------------------------------------------

PASCAL TRIANGLE

vector<int> arr; //used to store final output
    vector<int> clone; //used for swapping
    clone.push_back(1);
    arr.push_back(1);
    cin>>n;
    for(i=2;i<=n;i++)
    {
        clone.swap(arr);
        arr.resize(i);
        arr[0]=arr[i-1]=1;
        for(j=1;j<(i-1);j++)
            arr[j]=clone[j-1]+clone[j];
    }
    return arr;
 -------------------------------------------------------------------------

 ROTATE ARRAY BY K

i/p- 1 2 3 4 5 6 7
o/p- 5 6 7 1 2 3 4
  void reverse(vector<int>& nums,int start,int end)
    {
        int temp;
        while(start<end)
        {
            temp = nums[start];
            nums[start] = nums[end];
            nums[end] =temp;
            start++;
            end--;
        }
    }
    void rotate(vector<int>& nums, int k) {
        
        k = k%nums.size();
        reverse(nums,0,nums.size()-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.size()-1);
        
       
    }
    -------------------------------------------------------------
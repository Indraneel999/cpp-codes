*********ARRAYS*************

----------------------------------------------------------------------
        KADANEâ€™S ALGORITHM

    int ans = INT_MIN;
    int sum = 0;
    for(i = 0 to n) {
        sum += a[i];
        if(ans < sum)
        ans = sum;
        if(sum < 0)
            sum = 0;
    }

    Maximum Product Subarray

    int maxProduct(vector<int>& nums) {
        int maxproduct = nums[0];
        int minproduct = nums[0];
        int maxres = nums[0];
        for(int i = 1; i < nums.size(); i++) {
            if(nums[i] >= 0) {
                maxproduct = max(nums[i], maxproduct*nums[i]);
                minproduct = min(nums[i], minproduct*nums[i]);
            }
            else {
                int temp = maxproduct;
                maxproduct = max(nums[i], minproduct*nums[i]);
                minproduct = min(nums[i], temp*nums[i]);
            }
            maxres = max(maxres, maxproduct);
  }
        
        return maxres;
    }
---------------------------------------------------------------------------------------
    SUB-ARRAY WITH GIVEN SUM


    j=0;
    //s contains the desired sum
    while(t--)
    {
        result = 0;
        cin>>n>>s;
        arr.resize(n);
        for(i=0;i<n;i++)
        {
            cin>>arr[i];   
            result+=arr[i];  //checking while inserting
            while(result > s && j<=i)//keep removing element until result greater than sum
            {
                result-=arr[j];
                j++;
            }
            if(result == s)
            {
                cout<<j+1<<" "<<i+1<<"\n";
                break;  //stops taking input once the sum is matched
            }
        }
        if(i==n)
            cout<<"-1\n";
    }

  ----------------------------------------------------------
   SORT ARRAY CONTAINING 0 1 AND 2

 APPROACH 1
  using three way partitioning

  void sort_array(vector<long long> &a)
{
    //i is used to traverse the array 
    //low stores the starting location where next 0 is to be put
    //high stores the location where next 2 is to be placed
    long low=0,i=0,high = a.size()-1;
    while(i <= high)
    {
        if(a[i] == 0)
            swap(&a[i++],&a[low++]); //reference also works in vectors
        else
            if(a[i]==1)
                i++; // low and i will be different when we get first 1
        else
            if(a[i]==2)
                swap(&a[i],&a[high--]);
    } 
}

  APPROACH 2
   counting occurrences of 0 1 and 2


   void sort_array(vector<long long>& arr)
  {
    vector<long long> count(3,0);
    for(long long i=0;i<arr.size()-1;i++)
        count[arr[i]]++;
    for(long long i=0;i<count[0];i++)
        arr[i]=0;
    for(long long i=count[0];i<(count[1]+count[0]);i++)
        arr[i]=1;
    for(long long i=(count[1]+count[0]);i<arr.size();i++)
        arr[i]=2;
}

-------------------------------------------------------------------------

 REVERSE ARRAY IN GROUPS

        for(i=0;i<n;i+=k)
       {
           j=i;
           a=1;
           if((i+k)>n) //if it exceeds array size
                k = n-i;
             while(j<(i+k-a)) //swap with the corresponding element
            {
                temp = arr[j]; 
                arr[j] = arr[i+k-a]; // a is used to decrement end position each time
                arr[i+k-a] = temp;   
                j++;
                a++;
            }
         } 

 -----------------------------------------------------------------------------------
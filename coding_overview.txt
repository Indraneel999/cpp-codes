*********ARRAYS*************

----------------------------------------------------------------------
        KADANEâ€™S ALGORITHM

    int ans = INT_MIN;
    int sum = 0;
    for(i = 0 to n) {
        sum += a[i];
        if(ans < sum)
        ans = sum;
        if(sum < 0)
            sum = 0;
    }

    Maximum Product Subarray

    int maxProduct(vector<int>& nums) {
        int maxproduct = nums[0];
        int minproduct = nums[0];
        int maxres = nums[0];
        for(int i = 1; i < nums.size(); i++) {
            if(nums[i] >= 0) {
                maxproduct = max(nums[i], maxproduct*nums[i]);
                minproduct = min(nums[i], minproduct*nums[i]);
            }
            else {
                int temp = maxproduct;
                maxproduct = max(nums[i], minproduct*nums[i]);
                minproduct = min(nums[i], temp*nums[i]);
            }
            maxres = max(maxres, maxproduct);
  }
        
        return maxres;
    }
---------------------------------------------------------------------------------------
    SUB-ARRAY WITH GIVEN SUM


    j=0;
    //s contains the desired sum
    while(t--)
    {
        result = 0;
        cin>>n>>s;
        arr.resize(n);
        for(i=0;i<n;i++)
        {
            cin>>arr[i];   
            result+=arr[i];  //checking while inserting
            while(result > s && j<=i)//keep removing element until result greater than sum
            {
                result-=arr[j];
                j++;
            }
            if(result == s)
            {
                cout<<j+1<<" "<<i+1<<"\n";
                break;  //stops taking input once the sum is matched
            }
        }
        if(i==n)
            cout<<"-1\n";
    }

  ---------------------------------------------------------------------------
   SORT ARRAY CONTAINING 0 1 AND 2

 APPROACH 1
  using three way partitioning

  void sort_array(vector<long long> &a)
{
    //i is used to traverse the array 
    //low stores the starting location where next 0 is to be put
    //high stores the location where next 2 is to be placed
    long low=0,i=0,high = a.size()-1;
    while(i <= high)
    {
        if(a[i] == 0)
            swap(&a[i++],&a[low++]); //reference also works in vectors
        else
            if(a[i]==1)
                i++; // low and i will be different when we get first 1
        else
            if(a[i]==2)
                swap(&a[i],&a[high--]);
    } 
}

  APPROACH 2
   counting occurrences of 0 1 and 2


   void sort_array(vector<long long>& arr)
  {
    vector<long long> count(3,0);
    for(long long i=0;i<arr.size()-1;i++)
        count[arr[i]]++;
    for(long long i=0;i<count[0];i++)
        arr[i]=0;
    for(long long i=count[0];i<(count[1]+count[0]);i++)
        arr[i]=1;
    for(long long i=(count[1]+count[0]);i<arr.size();i++)
        arr[i]=2;
}

-------------------------------------------------------------------------

 REVERSE ARRAY IN GROUPS

        for(i=0;i<n;i+=k)
       {
           j=i;
           a=1;
           if((i+k)>n) //if it exceeds array size
                k = n-i;
             while(j<(i+k-a)) //swap with the corresponding element
            {
                temp = arr[j]; 
                arr[j] = arr[i+k-a]; // a is used to decrement end position each time
                arr[i+k-a] = temp;   
                j++;
                a++;
            }
         } 

 -----------------------------------------------------------------------------------

 TRAPPING RAIN WATER

 ll trapping_water(vector<ll> &arr)
{
    ll left=0,right=arr.size()-1; //to store the indices
    ll max_left=0,max_right=0; //to store the maximum height bar from left and right
    ll res=0;
    while(left<=right)
    {
        if(arr[left] < arr[right]) // need to check this else suppose decreasing order height
        {
            if(arr[left]>max_left)
                max_left = arr[left];
            else
                res+=max_left-arr[left];
            left++;
        }

        else
        {
            if(arr[right]>max_right)
                max_right = arr[right];
            else
                res+=max_right-arr[right];
            right--;
        }

    }
    return res;
}
-----------------------------------------------------------------------------------------
PYTHOGOREAN TRIPLET

bool find_triplet(vector<int> &arr)
{
    //recieved an array after squaring all of it's elements

    sort(arr.begin(),arr.end()); //sort
    ll left,right;
    for(ll i=arr.size()-1;i>1;i--)  
    { 
        left = 0;
        right = i-1;
        while(left < right) //apply meet in middle algorithm
        {
            if(arr[left]+arr[right]<arr[i])
                left++;
            else if(arr[left]+arr[right]>arr[i])
                right--;
            else 
                return 1;
        }
    }
    
    return 0;
}
